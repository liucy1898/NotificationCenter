
#JAVA DEV Specification

> 本文档旨在提供JAVA开发相关规范及最佳实践。

## 项目规范

+ 【强制】根包名必须是 com.schneider，项目内包的命名规则为 com.schneider.projectName.moduleName
+ 【推荐】项目结构中JAVA源代码放置在src目录下，web特定的页面或资源放置在WebContent目录下，需要保护的资源必须放置在WebContent/WEB-INF 目录下


## 命名规范

+ 【强制】禁止以特殊符号为开始的命名
+ 【强制】命名中，除业界惯用的缩写外，尽量用英文全拼单词
+ 【强制】类名采用Pascal风格,方法名，参数名，成员变量，局部变量统一采用camelCase 风格
+ 【强制】常量命名全部大写，单词间用下划线隔开
+ 【强制】抽象类型使用Abstract；异常类型以Exception结尾；测试类型以Test结尾
+ 【强制】包名统一采用小写，且采用单数形式，例如：com.schneider.util
+ 【推荐】如果使用了设计模式，建议在类的名称中予以体现，例如：PersonFactory
+ 【推荐】接口的成员不要添加任何作用范围修饰符， 尽量不要在接口内定义变量
+ 【推荐】对于JAVA8 规范允许接口有默认实现，要使用默认实现必须是对所有实现类型都是有价值的
+ 【推荐】接口实现可以用Impl结尾来命名
+ 【推荐】枚举类型的命名以Enum结尾
+ 【参考】POJO对象的命名中，DO结尾表示数据对象；DTO结尾表示数据传输对象


## 常量定义

+ 【强制】不允许使用Magic number
+ 【强制】 Long类型常量必须用大写L结尾

## 代码格式约定

+ 【强制】IF/FOR/WHILE等代码块必须使用{}
+ 【强制】任何运算符左右必须加一个空格
+ 【推荐】缩写采用4个空格，若使用tab缩进则tab必须等于4个空格
+ 【强制】单行字符不超过120个，折行后的后续行与第一行保持4个空格缩进
+ 【强制】IDE的text file encoding 使用UTF-8;IDE中文件换行符使用Unix格式，而不是windows格式
+ 【推荐】一个方法体内，关联紧密的代码块之间可以用空行隔开


## 面向对象编程实践

+ 【强制】避免通过类实例访问类型的静态成员，应该直接使用类名来访问即可
+ 【强制】所有方法的重写，必须加@override注解
+ 【推荐】尽量不推荐使用可变方法参数
+ 【强制】过时的接口，必须用@Deprecated 注解
+ 【强制】所有相同类型的基本类型包装类之间的值比较，必须使用equals方法
+ 【强制】所有POJO类型的属性必须使用基本类型的包装类；所有局部变量使用基本类型；RPC方法的返回值或参数必须使用包装类型
+ 【强制】POJO类型定义时，不要设定任何属性的默认值
+ 【强制】序列化类的新增属性时，不要修改serialVersionUID字段，避免反序列化失败
+ 【强制】构造方法内禁止加入业务逻辑，如果有初始化逻辑，请放入init方法内
+ 【强制】POJO类型必须显式的定义toString方法，如果继承自另一个POJO类型，则在本POJO类型的toString方法的第一行加上super.toString()
+ 【推荐】使用索引访问由字符串的split方法得到的数组时，要检查最后一个分隔符后无内容的检查
+ 【推荐】尽量不要在setter/getter方法内添加业务逻辑
+ 【强制】字符串的拼接，请使用StringBuilder
+ 【推荐】使用final的情况：不需要对值修改的类属性，变量成员或局部变量；类方法不允许被重写时
+ 【推荐】慎用Object 的clone，要注意这是一种浅拷贝
+ 【推荐】类及类型的成员的访问范围要控制到最小


## 集合处理

+ 【强制】只要重写equals，就必须重写hashCode；如果自定义对象做了Map的键，那么必须重写hashCode和equals
+ 【强制】使用集合转数组，必须使用集合的toArray(T[] array) 传入的是类型完全一样的数组
+ 【强制】使用Arrays.asList() 把数组转换为集合时，不能使用修改集合的方法来操作这个结果集合，因为.asList方法返回的是一个Arrays内部类，它其实并不是一个集合，而是一个数组
+ 【强制】不要在foreach遍历集合时对集合进行影响size的操作，如果需要操作，则请使用集合的Iterator来进行
+ 【强制】JDK7以上版本，Comparator需要满足自反性，传递性，对称性。 自反性是指x,y的比较结果与y,x的比较结果相反；传递性：x>y,y>z 则x>z; 对称性：x=y,则x,z比较结果和y,z比较结果相同
+ 【推荐】集合初始化时，尽量指定size大小
+ 【推荐】使用entrySet便利Map， 而不是用KeySet
+ 【参考】利用set数据结构的特性，可以快速对一个集合进行去重操作

## 并发编程

+ 【强制】单例对象的使用要保证线程安全
+ 【强制】手动创建线程时必须给线程指定有意义的名称
+ 【推荐】线程资源推荐通过线程池提供，不推荐单独手动创建线程
+ 【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式
+ 【强制】SimpleDateFormat不是线程安全的，不建议定义为static变量，即使定义为static，也必须加锁，或者使用DateUtils工具类
+ 【强制】同步锁的使用，应考虑性能损失，能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用锁
+ 【强制】对所个资源加锁时，需要保证一致的加锁顺序，避免死锁
+ 【强制】并发修改同一数据库记录时，可以在应用层或缓存加锁，在数据库加锁时，并发冲突概率较小时，推荐使用乐观锁，否则使用悲观锁，乐观锁重试次数不得小于3次
+ 【强制】使用定时任务时，Timer运行多个TimeTask时，只要没有捕获住异常会所有任务都会终止， 使用ScheduledExecutorService则没有此类问题
+ 【推荐】使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行。 子线程抛出的异常在主线程不能catch到
+ 【推荐】Random实例要避免多个线程同时共用，可能因为竞争同一seed导致性能下降。Random实例包括java.util.Random 或  Math.random(), JDK7之后可以使用ThreadLocalRandom，这个实例是每个线程都是单独的
+ 【推荐】使用双重检查锁来延迟实例化属性返回对象时，要将属性声明为volatile
+ 【参考】volatile对于一写多读，是可以解决变量同步问题，但是如果是多竞争写，也会有线程安全问题，对于计数累加的场景可以通过如下代码实现,如果是JDK8，则推荐使用LongAdder：
####
    AtomicInteger count = new AtomicInteger();
    count.addAndGet(1);
####
+ 【参考】HashMap在容量不足时进行resize操作，可能会因为高并发出现死链
+ 【参考】ThreadLocal对象推荐声明为static

## 控制流

+ 【强制】switch块内，每个case要么通过break/return来终止，且必须声明default部分
+ 【强制】避免过于复杂的if判断；避免深度超过两层的循环嵌套
+ 【推荐】循环语句内尽量不要进行定义对象，获取数据库连接这样的操作，以及使用try catch，如要捕获异常应该移到循环体外
+ 【参考】对方法参数进行校验时，要考虑性能代价，处处进行防御型的参数检查及校验并非良好实践


## 代码注释

+ 【强制】类及类型成员的注释必须使用javadoc规范
+ 【强制】所有抽象方法或接口必须添加注释，除对参数，返回值等签名进行说明外，还必须指明用途及上下文约束
+ 【强制】所有自定义类型必须添加作者及时间注释
+ 【强制】枚举类型必须有注释，说明每个枚举项的含义
+ 【强制】代码的修改，必须添加修改者及修改时间，修改意图的注释


## 异常处理

+ 【强制】不要捕获RuntimeException及派生的异常
+ 【强制】简单的对大段代码进行try catch是不良实践
+ 【强制】对于可以处理的异常就地处理，否则抛出给调用者处理
+ 【强制】在事务代码中try catch时捕获到异常，如果需要事务回滚，一定要手动回滚
+ 【强制】在finally中通常进行资源的释放，非托管资源的释放也需要使用try catch来保证资源最终释放成功
+ 【推荐】对于不可控的场景，类型检查，方法返回值检查是必要的：
####
    -- 返回类型为基本类型的包装类型，有可能为null
    -- 数据库的查询结果可能为null
    -- 集合元素可能为null
    -- RPC调用返回的对象，可能为null
    -- 从session中获取的数据，进行NPE检查，避免空指针

####

+ 【推荐】在代码中是抛出异常，还是返回错误码：对于系统对外暴露的接口使用错误码
+ 【推荐】对于业务异常，推荐自定义业务异常类型
+ 


## 数据库相关规范

+ 【强制】在数据库建模中，要保持模型与实际数据库的一致性
+ 【强制】存储过程要谨慎使用，尤其是包含复杂业务逻辑的存储过程不推荐使用，存储过程要有充分的注释予以说明意图及实现思路
+ 【强制】通过代码操作数据库，应通过ORM的方式，一般情况下禁止在代码中使用SQL语句
+ 【强制】Hibernate 等ORM的model定义中，不能直接使用基础类型，而应该使用包装类型
+ 【强制】HBM中 String的length大于1500时，建议使用Clob/Blob类型，且必须采用字段延迟加载
+ 【强制】在使用HQL查询语句时，WHERE条件的值必须参数化，这样既可以防范SQL注入，也可以提供执行性能

## 安全性

+ 【强制】敏感业务数据的写入，或在服务器端的敏感操作，都要进行数据检查校验，操作要进行严格权限控制
+ 【强制】在显示层，业务敏感或个人敏感信息采用服务器端过滤或做特殊处理
+ 【强制】页面输入项要注意避免脚本注入攻击
+ 【强制】表单，AJAX提交必须进行CSRF安全过滤（CSRF-跨站请求伪造）

---
作者：Chengyu Liu <chengyu-liucy.liu@schneider-electric.com>

日期：2017/04/25

Copyright @2017 schneider China